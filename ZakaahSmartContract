pragma solidity ^0.4.0;
contract Eethiq {
     
      
      address owner;
     uint  public zakaahCoins;
    
    function Eethiq(){
        owner=msg.sender;
        zakaahCoins=1000000;
        
    }
  
    struct Donor {
        bytes32 name;
        address addr;
        uint donorID;
        uint amount;
        uint[] transactionID;
       uint time;
    }
   
    mapping(address=>Donor)balances;
  
    struct Charity{
        bytes32 name;
        address addr;
        uint amount;
      
        uint charityID;  
        uint requestCash;
        uint numberR; 
        
        uint[] listProjects;
       
        uint[] requests;
        uint time;
    }
   
   
    mapping(uint=>Charity)charities;
   
    struct  Project{
       address addr;
        bytes32 name;
        uint charityID;
        uint fundingGoal;
        
        uint amount;
        uint cash;
       
        bytes32 category;
        bytes32 impact;
        uint projectID;
        uint time;
        uint[] listDonors;
        uint[] transactionList;
    }
  
   
    uint public numProjects;
    
    uint public numCharities;
   
    mapping (uint => Project)projects;
   
    function bytes32ToString(bytes32 x) constant returns (string) {
    bytes memory bytesString = new bytes(32);
    uint charCount = 0;
    for (uint j = 0; j < 32; j++) {
        byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
        if (char != 0) {
            bytesString[charCount] = char;
            charCount++;
        }
    }
    bytes memory bytesStringTrimmed = new bytes(charCount);
    for (j = 0; j < charCount; j++) {
        bytesStringTrimmed[j] = bytesString[j];
    }
    return string(bytesStringTrimmed);
}

   
    uint[]  category1;
    uint[] category2;
    uint[] category3;
    uint[]  category4;
    uint[]  category5;
    uint[]  category6;
 
  
    function newProject(bytes32 name, uint charityID, uint goal, uint categoryID) {
        numProjects++; 
        uint projectID=numProjects;
        Project p = projects[projectID]; // assigns reference
        p.charityID = charityID;
        charities[charityID].listProjects.push(projectID);
        p.fundingGoal = goal;
        p.cash=0;
       p.addr=msg.sender;
        p.name=name;
     p.projectID=numProjects;
       p.time=now;
          if(categoryID==1){
                 p.category="Trafficking Victims";
                 category1.push(projectID);
             }
          else if(categoryID==2){
                 p.category="Refugees/IDPs";
                 category2.push(projectID);
             }
          else if(categoryID==3){
                 p.category="Microfinance Clients";
                category3.push(projectID);
             }
           else if(categoryID==4){
                p.category ="Education";
                 category4.push(projectID);
             }
            else if(categoryID==5){
                  p.category ="Disaster Victims";
                 category5.push(projectID);
             }
            else{
                  p.category ="Poverty Alleviation";
                  category6.push(projectID);
            }
                
        p.impact="To be estimated";
      
    }
  
 
    function impact(uint projectID, bytes32 impact) {
      if(msg.sender!=projects[projectID].addr){
          throw;
      }
        projects[projectID].impact=impact;
      
    }

   
    function newCharity(bytes32 name){
         if(name==""){
           throw;
       }
        numCharities++;
        uint charityID=numCharities;
        Charity c=charities[charityID];
        c.name=name;
        c.addr=msg.sender;
      c.charityID=charityID;
     c.time=now;
    }


uint public  numTransactions;


struct Transaction{
    address sender;
    uint receiverID;
    uint ID;
    uint amount;
    uint time;
   
} 

    mapping(uint=>Transaction)public transactions;
    
    event Contribute(bool done);
   
    function donate(uint projectID, uint amount)returns (bool success) {
       if (projects[projectID].amount >= projects[projectID].fundingGoal){
        Contribute(false);
        return false;
        }
        
        if(msg.sender!=balances[msg.sender].addr){
           Contribute(false);
           return false;
        }
        if(balances[msg.sender].amount<amount){
            Contribute(false);
            return false;
        }
        uint remamount=projects[projectID].fundingGoal-projects[projectID].amount;
        if(remamount<amount){
            Contribute(false);
           return false;
        }
        Project p = projects[projectID];
        
        p.amount += amount;
        balances[msg.sender].amount-=amount;
        p.listDonors.push(balances[msg.sender].donorID);
        	numTransactions++;
		 Transaction t=transactions[numTransactions];
               t.sender=msg.sender;
               t.receiverID=projectID;
               t.ID=numTransactions;
               t.amount=amount;
               t.time=now;
               balances[msg.sender].transactionID.push(numTransactions);
               p.transactionList.push(numTransactions);
               Contribute(true);
               return true;
               
        
    }
    uint public numDonors;
    function newDonor(bytes32 name){
        if(name==""){
            throw;
        }

        numDonors++;
        balances[msg.sender].addr=msg.sender;
        balances[msg.sender].donorID=numDonors;
        balances[msg.sender].name=name;
        balances[msg.sender].time=now;
        
    }
  
   
     function buyCoins( uint amount){
       if(msg.sender!=balances[msg.sender].addr){
         
          throw;
       }
        uint increaseCoin = amount;
        if(zakaahCoins<amount){
            throw;
        }
        balances[msg.sender].amount += increaseCoin;
        zakaahCoins-=amount;
		  
               numTransactions++;
               transactions[numTransactions].ID=numTransactions;
               transactions[numTransactions].sender=owner;
               transactions[numTransactions].receiverID=balances[msg.sender].donorID;
               
               transactions[numTransactions].ID=numTransactions;
               transactions[numTransactions].amount=amount;
             
               transactions[numTransactions].time=now;
                balances[msg.sender].transactionID.push(numTransactions);
               
             
              

     }
   
    
   function donorData()constant returns(string name, address addr, uint donorID, uint amount, uint time){
       name=bytes32ToString(balances[msg.sender].name);
       return(name,balances[msg.sender].addr, balances[msg.sender].donorID, balances[msg.sender].amount, balances[msg.sender].time);
       
   } 
   
   function donorTrans()constant returns(uint[] transactionID){
       return balances[msg.sender].transactionID;
   }
   
   function projectData(uint projectID)constant returns(string name,  uint charityID,uint fundingGoal,uint amount,uint cash,address addr,string category,string impact, uint pID, uint time){
       category=bytes32ToString(projects[projectID].category);
       impact=bytes32ToString(projects[projectID].impact);
       name=bytes32ToString(projects[projectID].name);
       charityID=projects[projectID].charityID;
       fundingGoal=projects[projectID].fundingGoal;
      
       amount=projects[projectID].amount;
       cash=projects[projectID].cash;
      addr=projects[projectID].addr;
       pID=projects[projectID].projectID;
       time=projects[projectID].time;
       return(name,charityID,fundingGoal,amount,cash,addr,category,impact,pID,time);
   }
   function donorsProjects(uint projectID)constant returns(uint[] listDonors){
       return projects[projectID].listDonors;
   }
    function transProjects(uint projectID)constant returns(uint[] transactionList){
       return projects[projectID].transactionList;
   }
   
    function kill() {
        
        if (msg.sender != owner){
            throw;
        } 
        selfdestruct(owner);
    }
    
    function charityData(uint charityID)constant returns(string name,address addr,  uint ID, uint time){
        name=bytes32ToString(charities[charityID].name);
        return (name,charities[charityID].addr,charities[charityID].charityID, charities[charityID].time);
    }
    function charityProjects(uint charityID)constant returns(uint[] listProjects){
        return charities[charityID].listProjects;
    }
   
    function charityRequests(uint charityID)constant returns(uint[] requests){
        return charities[charityID].requests;
    } 
    
    function getImpact(uint projectID)constant returns(string impact){
        impact=bytes32ToString(projects[projectID].impact);
        return impact;
    }
    function getCategory(uint categoryID)constant returns(uint[] category){
        if(categoryID==1){
            return category1;
        }
        else if(categoryID==2){
            return category2;
        }
        else if(categoryID==3){
            return category3;
        }
        else if(categoryID==4){
            return category4;
            
        }
        else if(categoryID==5){
            return category5;
        }
        else
        return category6;
    }
    
  
}
